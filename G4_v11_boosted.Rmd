---
title: "Evaluation of lock-down effect in several European countries"
author: "M. Noujaim, Q. Shi, M. Parashar, A. Bouzid, C. Alvear"
output:
  html_document:
    theme: paper
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    includes:
always_allow_html: yes
---

<!-- **Note:** Assuming the working directory is "MYDIRECTORY/INSEADAnalytics" (where you have cloned the course material), you can create an html file by running in your console the command (pay attention to the directory you are in, check it using getwd()) rmarkdown::render("CourseSessions/InClassProcess/MarketSegmentationProcessInClass.Rmd") -->


<hr>\clearpage


# 1. Introduction

The unfolding, global COVID-19 pandemic is a human crisis of historic scale and complexity. It is straining healthcare systems, government financial capabilities, and the ability of many organizations to cope with the changes wrought by the virus and the response to it. The level of uncertainty for most leaders has been unprecedented, and most of our frameworks for planning and problem solving were unable to manage the geographic variability, uncertainty, and the exponential change brought by the COVID-19 crisis.

Government decisions for lockdown were mainly made by compromising between healthcare capabilities and economic disaster. The timing of governements' initiatives were often ambiguous and have been constantly being revised. 

Mitigate the econonomic impact of the Covid-19 and assess the stringency level of confinement have finally pushed governments to pronounce lockdowns at different moments. 
If all countries lacked experience in maganing such a crisis, Italian lockdown decision was taken after patient 0 was discovered and after what we commonly call a "tipping point", that is when the virus had already spread fast. French decision was taken a week after Italy. Finally, United Kingdom, in political and economic trouble due to the Brexit situation, waited a week more than France to announce the confinement. 

How did those delays affected the spread of the virus and mortality?
How long should be the lockdown period in each country and ultimately which country has best managed the situation?  

We will then compare countries to one another and evaluate how the timing of public policy decisions (Lockdown) has affected the control of the Covid-19 pandemic spread.

<hr>\clearpage

# 2. The Project Initiative

The project aims at analyzing the effect of the lockdown policies in Italy, France and United Kingdom and then observe the change in the mortality curve predictions. 
We will put ourselves in the shoes of Government decision makers at different dates and analyze the public data available to come up with predictive models of mortality. We will create several time-series models to predict the cumulative deaths with the information at the lockdown date, 14 days, 28 days and 56 days later.

<hr>\clearpage

# 3. The Process

The project methodology is a time-series modeling and implementation to evaluate future mortality. 

Firstly, we want to see how was the situation when the Lockdown was decided. 
For instance, in the case of Italy, the deaths before the lockdown (until March 9th 2020) were already growing at an exponential rate. So we would first like to see how was the prediction this day and estimate how many lives were saved thanks to the lockdown imposition by comparing the prediciton with the actual data.

Secondly, because the virus can incubate for up to 2 weeks before the first symptoms appear, we will also look at the prediction 14 days after the Lockdown decision. With more data available but without the direct impact of the Lockdown (due to the incubation period), this model should have narrower and more accurate confidence interval.  The first two dates will compare early predictions with the real death toll to know how many lives were saved and how the virus contamination was slowed down in each country.

Nevertheless, both first models would note take into account the lockdown effect, which should drastically change the spread of the virus and so further predictions. To do so, we would look at prediction 28 days after the lockdown start which should help measuring the assumed positive effect of lockdown. 

Finally, the latest prediction, being done 8 weeks after the lockdown date with the latest data available (May 25th), should be a good indicator of the current situation of the crisis and of the level of control and certainty about the pandemic evolution. This will give us insights on how the delay in lockdown dates for each country has affected the spread curve of the Coronavirus over 8 weeks. It will ultimately indicate whether lockdown shall be ended or pursued.

At the end of the process, we will be able to compare different lockdown impacts on mortality predictions and will determine which countries are in good position for ending the lockdown. Considering end of confinement also means economy restart, it would also give us a sense of which lockdown and stringency policy decisions were the most effective from an economic perspective. Indeed, the earlier the end of lockdown, the better for the economy. 

## The Data Set 

The data set is extracted from the Covid-19 official Europe Data Website (source:https://data.europa.eu/euodp/en/data/dataset/covid-19-coronavirus-data)
It contains the 2020 daily evolution of Deaths and confirmed cases by country. 

We will start by importing the dataset 
```{r, echo=TRUE}
covid_data <- read.csv("COVID_data_v3.csv", header=TRUE, sep=",")
#ProjectData <- data.matrix(ProjectData) 
#ProjectData_INITIAL <- ProjectData
```

## Timeseries Dataframe
The timeseries starting point will always be the day in which the first death was recensed for each country. In the case of Italy, first death was on February 23rd January 2020, (day 54 of 2020 - Line 55 of the dataset). 
Reference Start Day will be considered January 1,2020 as we do not have data for 2019 in the selected countries. 
For time series, a minimum of periods is needed to perform analysis, so we reduced the frequency to days instead of months or years because Covid-19 is very new so we could not have yearly nor monthly background. 

The below graphs show the real data given by the official Covid-19 Europe Data Webiste till May 25th, 2020.
The vertical green line represents the lockdown date in the country (For Italy it is March 9th which is 65 days after January 1,2020). 
The red data line refers to the data we will take into account for predicting future mortality. This interval will change depending on the date in which we analyze the data. For instance, to perform the prediction at the lockdown date, we will take into account all dates between the first death till the lockdown date. 
The black line is the real death toll of the country given by the official Covid-19 Europe Data Webiste till May 25th, 2020.

This timeseries dataframe will be updated by date and countries before performing different date predictions. 

### Italian Data
```{r, echo=FALSE}
t0_IT=2020+53/365 #day of first casualty
P=15 #predicted days
cIT2_0 <- ts((covid_data$Cdeaths_IT[54:69]),start=t0_IT, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cIT3 <- ts((covid_data$Cdeaths_IT[54:146]),start=t0_IT, frequency=365)

plot(cIT3, xlab="Time", ylab="Accumulated deaths (Italy)")
lines(cIT2_0, col="red")
abline(v=2020+69/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

### French Data
```{r, echo=FALSE}
#French Data
t0_FR <- 2020+46/365
cFRA2_0 <- ts(covid_data$Cdeaths_FRA[46:75],start=t0_FR, frequency=365) #t=0 @ day75, March 15th #before it was starting at 45
cFRA3 <- ts(covid_data$Cdeaths_FRA[46:146],start=t0_FR, frequency=365)

plot(cFRA3, xlab="Time", ylab="Accumulated deaths (France)")
lines(cFRA2_0, col="red")
abline(v=2020+75/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

### UK Data
```{r, echo=FALSE}
#UK Data

t0_UK=2020+67/365
cUK2_0 <- ts(covid_data$Cdeaths_UK[67:83],start=t0_UK, frequency=365) #t=0 @ day83. +0d
cUK3 <- ts(covid_data$Cdeaths_UK[67:146],start=t0_UK, frequency=365)

plot(cUK3, xlab="Time", ylab="Accumulated deaths (UK)")
lines(cUK2_0, col="red")
abline(v=2020+83/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)


```
## Predictions at Lockdown Date 

### Italy at Lockdown Date

For reading purpose, we will only present the comprehensive process for Italy at Lockdown. We will then only show the results of the best plot for others countries and other dates with some comments. 

### Prediction Methodology 
We will perform different types of timeseries models:
```{r, echo=FALSE}
library(forecast)
#Italy
cIT2_0_AAN <- ets(cIT2_0, model="AAN", damped=FALSE)
cIT2_0_AAZ <- ets(cIT2_0, model="AAZ", damped=FALSE)
cIT2_0_MMN <- ets(cIT2_0, model="MMN", damped=FALSE)
cIT2_0_MMZ <- ets(cIT2_0, model="MMZ", damped=FALSE)

cIT2_0_AAND <- ets(cIT2_0, model="AAN", damped=TRUE)
cIT2_0_AAZD <- ets(cIT2_0, model="AAZ", damped=TRUE)
cIT2_0_MMND <- ets(cIT2_0, model="MMN", damped=TRUE)
cIT2_0_MMZD <- ets(cIT2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
```
```{r, echo=FALSE}
cIT2_0_AAN_pred <- forecast(cIT2_0_AAN, h=P, level=c(0.8, 0.95))
cIT2_0_AAZ_pred <- forecast(cIT2_0_AAZ, h=P, level=c(0.8, 0.95))
cIT2_0_MMN_pred <- forecast(cIT2_0_MMN, h=P, level=c(0.8, 0.95))
cIT2_0_MMZ_pred <- forecast(cIT2_0_MMZ, h=P, level=c(0.8, 0.95))

cIT2_0_AAND_pred <- forecast(cIT2_0_AAND, h=P, level=c(0.8, 0.95))
cIT2_0_AAZD_pred <- forecast(cIT2_0_AAZD, h=P, level=c(0.8, 0.95))
cIT2_0_MMND_pred <- forecast(cIT2_0_MMND, h=P, level=c(0.8, 0.95))
cIT2_0_MMZD_pred <- forecast(cIT2_0_MMZD, h=P, level=c(0.8, 0.95))
```
```{r, echo=FALSE}
cIT2_0_tbats <- tbats(cIT2_0)
cIT2_0_tbats_pred <-forecast(cIT2_0_tbats, h=P, level=c(0.8, 0.95))
```
```{r, echo=FALSE}
cIT2_0_ARIMA <- auto.arima(cIT2_0,seasonal=FALSE)
cIT2_0_ARIMA_pred <- forecast(cIT2_0_ARIMA,P)
```
### Exponential Smoothing
We tried 8 models of Exponential Smoothing (ETS) but will only take 4 into account for the further prediction models which are additive and multiplicative with and without dampening: AAN, MMN, AMND, MMND 

Indeed, the death curve is cumulative and so there will be no seasonality.
```{r, echo=FALSE}
par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT2_0_AAN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_AAZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT2_0_AAND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_AAZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
```
The 4 ETS Models to retain are the following:
```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

### TBATS

Decomposition model trigonometric TBATS. TBATS will become BATS because of no seasonality so no need for trigonomectric adjustment. 
```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (Italy)")
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

### Auto-regressive Method ARIMA

We will finally select the model that fits the best for the first country and will further reproduce the same process other countries. Finally we will present 3 best plots for each country
```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (Italy)")
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

### Cross-Validation 

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```

```{r, echo=TRUE}
mean(abs(errors_AANF/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMNF/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_AAND/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMND/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_TBATS/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cIT2_0), na.rm=TRUE)*100

```
Best model is MMN for Italy
```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```


### France at Lockdown Date

```{r, echo=FALSE}
library(forecast)
#Italy
cFRA2_0_AAN <- ets(cFRA2_0, model="AAN", damped=FALSE)
cFRA2_0_AAZ <- ets(cFRA2_0, model="AAZ", damped=FALSE)
cFRA2_0_MMN <- ets(cFRA2_0, model="MMN", damped=FALSE)
cFRA2_0_MMZ <- ets(cFRA2_0, model="MMZ", damped=FALSE)

cFRA2_0_AAND <- ets(cFRA2_0, model="AAN", damped=TRUE)
cFRA2_0_AAZD <- ets(cFRA2_0, model="AAZ", damped=TRUE)
cFRA2_0_MMND <- ets(cFRA2_0, model="MMN", damped=TRUE)
cFRA2_0_MMZD <- ets(cFRA2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA2_0_AAN_pred <- forecast(cFRA2_0_AAN, h=P, level=c(0.8, 0.95))
cFRA2_0_AAZ_pred <- forecast(cFRA2_0_AAZ, h=P, level=c(0.8, 0.95))
cFRA2_0_MMN_pred <- forecast(cFRA2_0_MMN, h=P, level=c(0.8, 0.95))
cFRA2_0_MMZ_pred <- forecast(cFRA2_0_MMZ, h=P, level=c(0.8, 0.95))

cFRA2_0_AAND_pred <- forecast(cFRA2_0_AAND, h=P, level=c(0.8, 0.95))
cFRA2_0_AAZD_pred <- forecast(cFRA2_0_AAZD, h=P, level=c(0.8, 0.95))
cFRA2_0_MMND_pred <- forecast(cFRA2_0_MMND, h=P, level=c(0.8, 0.95))
cFRA2_0_MMZD_pred <- forecast(cFRA2_0_MMZD, h=P, level=c(0.8, 0.95))

cFRA2_0_tbats <- tbats(cFRA2_0)
cFRA2_0_tbats_pred <-forecast(cFRA2_0_tbats, h=P, level=c(0.8, 0.95))

cFRA2_0_ARIMA <- auto.arima(cFRA2_0,seasonal=FALSE)
cFRA2_0_ARIMA_pred <- forecast(cFRA2_0_ARIMA,P)


#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
#lines(cFRA3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
#lines(cFRA3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
#lines(cFRA3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
#lines(cFRA3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (FR)")
#lines(cFRA3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cFRA2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (FR)")
#lines(cFRA3, col="red")


```

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```


```{r, echo=FALSE}

#mean(abs(errors_AANF/cFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_AAND/cFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_MMND/cFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cFRA2_0), na.rm=TRUE)*100

```
Best model is TBATS for France:

```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")
abline(v=2020+75/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```



### UK at Lockdown Date

```{r, echo=FALSE}
library(forecast)
#Italy
cUK2_0_AAN <- ets(cUK2_0, model="AAN", damped=FALSE)
cUK2_0_AAZ <- ets(cUK2_0, model="AAZ", damped=FALSE)
cUK2_0_MMN <- ets(cUK2_0, model="MMN", damped=FALSE)
cUK2_0_MMZ <- ets(cUK2_0, model="MMZ", damped=FALSE)

cUK2_0_AAND <- ets(cUK2_0, model="AAN", damped=TRUE)
cUK2_0_AAZD <- ets(cUK2_0, model="AAZ", damped=TRUE)
cUK2_0_MMND <- ets(cUK2_0, model="MMN", damped=TRUE)
cUK2_0_MMZD <- ets(cUK2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK2_0_AAN_pred <- forecast(cUK2_0_AAN, h=P, level=c(0.8, 0.95))
cUK2_0_AAZ_pred <- forecast(cUK2_0_AAZ, h=P, level=c(0.8, 0.95))
cUK2_0_MMN_pred <- forecast(cUK2_0_MMN, h=P, level=c(0.8, 0.95))
cUK2_0_MMZ_pred <- forecast(cUK2_0_MMZ, h=P, level=c(0.8, 0.95))

cUK2_0_AAND_pred <- forecast(cUK2_0_AAND, h=P, level=c(0.8, 0.95))
cUK2_0_AAZD_pred <- forecast(cUK2_0_AAZD, h=P, level=c(0.8, 0.95))
cUK2_0_MMND_pred <- forecast(cUK2_0_MMND, h=P, level=c(0.8, 0.95))
cUK2_0_MMZD_pred <- forecast(cUK2_0_MMZD, h=P, level=c(0.8, 0.95))

cUK2_0_tbats <- tbats(cUK2_0)
cUK2_0_tbats_pred <-forecast(cUK2_0_tbats, h=P, level=c(0.8, 0.95))

cUK2_0_ARIMA <- auto.arima(cUK2_0,seasonal=FALSE)
cUK2_0_ARIMA_pred <- forecast(cUK2_0_ARIMA,P)

#par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
#plot(cUK2_0_AAN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_AAZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

#par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
#plot(cUK2_0_AAND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_AAZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
#lines(cUK3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
#lines(cUK3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
#lines(cUK3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
#lines(cUK3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (UK)")
#lines(cUK3, col="red")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cUK2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (UK)")
#lines(cUK3, col="red")


```

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```


```{r, echo=FALSE}

#mean(abs(errors_AANF/cUK2_0), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cUK2_0), na.rm=TRUE)*100
#mean(abs(errors_AAND/cUK2_0), na.rm=TRUE)*100
#mean(abs(errors_MMND/cUK2_0), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cUK2_0), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cUK2_0), na.rm=TRUE)*100

```
Best model is BATS for UK:

```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")
abline(v=2020+83/365, col="green")
legend("topleft", legend=c("Expected death toll","Used Data", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)
```

By looking at the prediction at the different lockdown dates, UK predictions were the most favorable. However the red curve indicates that the death toll was actually much more severe. The main reason for that result is the fact that UK had less data and that the tipping point had not been reached, thus engendering some sort of more linear expectations rather than a classic exponential pandemic curve. One other reason could be that the English citizen did not act as seriously as French or Italian citizens and that the virus kept spreading fast. 

Concerning Italy, the curve was very preoccupying. Reality was found to be better handled certainly thanks to the right amount of healthcare available to maintain the curve less exponential. 

Finally the French prediction was quite accurate with the real scenario.



### Exponential growth at lockdown date 

We can also think and verify that just before the lockdown, the deaths were exponential so we can create exponential growth models with the same data set but with log tranformation. Those models would be the upper limit of the death toll
Looking at the graphic below, we can say that the slope in the logarith;ic graph has decreased after the lockdown in the three coutries.

```{r, echo=FALSE}

t0_IT=2020+53/365 #day of first casualty
P=15 #predicted days
cLIT2_0 <- ts(log(covid_data$Cdeaths_IT[54:69]),start=t0_IT, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cLIT3 <- ts(log(covid_data$Cdeaths_IT[54:146]),start=t0_IT, frequency=365)

plot(cLIT3, xlab="Time", ylab="log(Accumulated deaths (FR))")
lines(cLIT2_0, col="red")
abline(v=2020+69/365, col="green")
legend("bottomright", legend=c("Real death toll [log]","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)



#French Data
t0log_FR <- 2020+66/365
cLFRA2_0 <- ts(log(covid_data$Cdeaths_FRA[67:75]),start=t0log_FR, frequency=365) #t=0 @ day75, March 15th #before it was starting at 45
cLFRA3 <- ts(log(covid_data$Cdeaths_FRA[67:146]),start=t0log_FR, frequency=365)

plot(cFRA3, xlab="Time", ylab="log(Accumulated deaths (France))")
lines(cLFRA2_0, col="red")
abline(v=2020+75/365, col="green")
legend("bottomright", legend=c("Real death toll [log]","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)


#UK Data

t0_UKlog=2020+68/365
cLUK2_0 <- ts(log(covid_data$Cdeaths_UK[69:83]),start=t0_UKlog, frequency=365) #t=0 @ day83. +0d
cLUK3 <- ts(log(covid_data$Cdeaths_UK[69:146]),start=t0_UKlog, frequency=365)

plot(cLUK3, xlab="Time", ylab="log(Accumulated deaths (UK))")
lines(cLUK2_0, col="red")
abline(v=2020+83/365, col="green")
legend("bottomright", legend=c("Real death toll [log]","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)


```

So before the lockdown, we confirm that the death tolls grow exponentially.

Now, we'll run 6 models for each country (4 ETS models, one TBATS and one ARIMA) and we keep the best fit using minimum absolute error with a rolling horizon cross validation.

#### Italy at Lock Down Date using exponential growth model
```{r, echo=FALSE}
library(forecast)
#FR
cLIT2_0_AAN <- ets(cLIT2_0, model="AAN", damped=FALSE)
cLIT2_0_AAZ <- ets(cLIT2_0, model="AAZ", damped=FALSE)
cLIT2_0_MMN <- ets(cLIT2_0, model="MMN", damped=FALSE)
cLIT2_0_MMZ <- ets(cLIT2_0, model="MMZ", damped=FALSE)

cLIT2_0_AAND <- ets(cLIT2_0, model="AAN", damped=TRUE)
cLIT2_0_AAZD <- ets(cLIT2_0, model="AAZ", damped=TRUE)
cLIT2_0_MMND <- ets(cLIT2_0, model="MMN", damped=TRUE)
cLIT2_0_MMZD <- ets(cLIT2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cLIT2_0_AAN_pred <- forecast(cLIT2_0_AAN, h=P, level=c(0.8, 0.95))
cLIT2_0_AAZ_pred <- forecast(cLIT2_0_AAZ, h=P, level=c(0.8, 0.95))
cLIT2_0_MMN_pred <- forecast(cLIT2_0_MMN, h=P, level=c(0.8, 0.95))
cLIT2_0_MMZ_pred <- forecast(cLIT2_0_MMZ, h=P, level=c(0.8, 0.95))

cLIT2_0_AAND_pred <- forecast(cLIT2_0_AAND, h=P, level=c(0.8, 0.95))
cLIT2_0_AAZD_pred <- forecast(cLIT2_0_AAZD, h=P, level=c(0.8, 0.95))
cLIT2_0_MMND_pred <- forecast(cLIT2_0_MMND, h=P, level=c(0.8, 0.95))
cLIT2_0_MMZD_pred <- forecast(cLIT2_0_MMZD, h=P, level=c(0.8, 0.95))

cLIT2_0_tbats <- tbats(cLIT2_0)
cLIT2_0_tbats_pred <-forecast(cLIT2_0_tbats, h=P, level=c(0.8, 0.95))

cLIT2_0_ARIMA <- auto.arima(cLIT2_0,seasonal=FALSE)
cLIT2_0_ARIMA_pred <- forecast(cLIT2_0_ARIMA,P)


par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_AAN_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_MMN_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_AAND_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_MMND_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_tbats_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")

```

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cLIT2_0, f_AANF, h=1, window=13)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cLIT2_0, f_MMNF, h=1, window=13)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cLIT2_0, f_AAND, h=1, window=13)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cLIT2_0, f_MMND, h=1, window=13)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cLIT2_0, f_TBATS, h=1, window=13)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cLIT2_0, f_ARIMA, h=1, window=13)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```


```{r, echo=FALSE}
mean(abs(errors_AANF/cLIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMNF/cLIT2_0), na.rm=TRUE)*100
mean(abs(errors_AAND/cLIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMND/cLIT2_0), na.rm=TRUE)*100
mean(abs(errors_TBATS/cLIT2_0), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cLIT2_0), na.rm=TRUE)*100

```
Best model is ARIMA for Italy:

```{r, echo=FALSE}

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLIT2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (Italy))", ylim=c(0,20))
lines(cLIT3, col="red")
abline(v=2020+69/365, col="green")
```

So now let's plot this result in deaths over time

```{r, echo=FALSE}
expforeIT_mean<-exp(cLIT2_0_ARIMA_pred$mean)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(expforeIT_mean, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,1e4))
lines(cIT3, col="red")
abline(v=2020+69/365, col="green")

```


#### France at Lock Down Date using exponential growth model
```{r, echo=FALSE}

library(forecast)
#FR
cLFRA2_0_AAN <- ets(cLFRA2_0, model="AAN", damped=FALSE)
cLFRA2_0_AAZ <- ets(cLFRA2_0, model="AAZ", damped=FALSE)
cLFRA2_0_MMN <- ets(cLFRA2_0, model="MMN", damped=FALSE)
cLFRA2_0_MMZ <- ets(cLFRA2_0, model="MMZ", damped=FALSE)

cLFRA2_0_AAND <- ets(cLFRA2_0, model="AAN", damped=TRUE)
cLFRA2_0_AAZD <- ets(cLFRA2_0, model="AAZ", damped=TRUE)
cLFRA2_0_MMND <- ets(cLFRA2_0, model="MMN", damped=TRUE)
cLFRA2_0_MMZD <- ets(cLFRA2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cLFRA2_0_AAN_pred <- forecast(cLFRA2_0_AAN, h=P, level=c(0.8, 0.95))
cLFRA2_0_AAZ_pred <- forecast(cLFRA2_0_AAZ, h=P, level=c(0.8, 0.95))
cLFRA2_0_MMN_pred <- forecast(cLFRA2_0_MMN, h=P, level=c(0.8, 0.95))
cLFRA2_0_MMZ_pred <- forecast(cLFRA2_0_MMZ, h=P, level=c(0.8, 0.95))

cLFRA2_0_AAND_pred <- forecast(cLFRA2_0_AAND, h=P, level=c(0.8, 0.95))
cLFRA2_0_AAZD_pred <- forecast(cLFRA2_0_AAZD, h=P, level=c(0.8, 0.95))
cLFRA2_0_MMND_pred <- forecast(cLFRA2_0_MMND, h=P, level=c(0.8, 0.95))
cLFRA2_0_MMZD_pred <- forecast(cLFRA2_0_MMZD, h=P, level=c(0.8, 0.95))

cLFRA2_0_tbats <- tbats(cLFRA2_0)
cLFRA2_0_tbats_pred <-forecast(cLFRA2_0_tbats, h=P, level=c(0.8, 0.95))

cLFRA2_0_ARIMA <- auto.arima(cLFRA2_0,seasonal=FALSE)
cLFRA2_0_ARIMA_pred <- forecast(cLFRA2_0_ARIMA,P)


#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLFRA2_0_AAN_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
##lines(cLFRA3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLFRA2_0_MMN_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
#lines(cLFRA3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
##plot(cLFRA2_0_AAND_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
#lines(cLFRA3, col="red")
##abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLFRA2_0_MMND_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
#lines(cLFRA3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLFRA2_0_tbats_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
#lines(cLFRA3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLFRA2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
#lines(cLFRA3, col="red")
#abline(v=2020+75/365, col="green")

```

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cLFRA2_0, f_AANF, h=1, window=8)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cLFRA2_0, f_MMNF, h=1, window=8)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cLFRA2_0, f_AAND, h=1, window=8)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cLFRA2_0, f_MMND, h=1, window=8)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cLFRA2_0, f_TBATS, h=1, window=8)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cLFRA2_0, f_ARIMA, h=1, window=8)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```


```{r, echo=TRUE}
#mean(abs(errors_AANF/cLFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cLFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_AAND/cLFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_MMND/cLFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cLFRA2_0), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cLFRA2_0), na.rm=TRUE)*100

```

Best model is ARIMA for FR:

```{r, echo=FALSE}

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLFRA2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
lines(cLFRA3, col="red")
abline(v=2020+75/365, col="green")
```

So now let's plot this result in deaths over time

```{r, echo=FALSE}
expforeFRA_mean<-exp(cLFRA2_0_ARIMA_pred$mean)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(expforeFRA_mean, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,1e4))
abline(v=2020+75/365, col="green")
lines(cFRA3, col="red")



```

#### UK at Lock Down Date using exponential growth model
```{r, echo=FALSE}
library(forecast)
#UK
cLUK2_0_AAN <- ets(cLUK2_0, model="AAN", damped=FALSE)
cLUK2_0_AAZ <- ets(cLUK2_0, model="AAZ", damped=FALSE)
cLUK2_0_MMN <- ets(cLUK2_0, model="MMN", damped=FALSE)
cLUK2_0_MMZ <- ets(cLUK2_0, model="MMZ", damped=FALSE)

cLUK2_0_AAND <- ets(cLUK2_0, model="AAN", damped=TRUE)
cLUK2_0_AAZD <- ets(cLUK2_0, model="AAZ", damped=TRUE)
cLUK2_0_MMND <- ets(cLUK2_0, model="MMN", damped=TRUE)
cLUK2_0_MMZD <- ets(cLUK2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cLUK2_0_AAN_pred <- forecast(cLUK2_0_AAN, h=P, level=c(0.8, 0.95))
cLUK2_0_AAZ_pred <- forecast(cLUK2_0_AAZ, h=P, level=c(0.8, 0.95))
cLUK2_0_MMN_pred <- forecast(cLUK2_0_MMN, h=P, level=c(0.8, 0.95))
cLUK2_0_MMZ_pred <- forecast(cLUK2_0_MMZ, h=P, level=c(0.8, 0.95))

cLUK2_0_AAND_pred <- forecast(cLUK2_0_AAND, h=P, level=c(0.8, 0.95))
cLUK2_0_AAZD_pred <- forecast(cLUK2_0_AAZD, h=P, level=c(0.8, 0.95))
cLUK2_0_MMND_pred <- forecast(cLUK2_0_MMND, h=P, level=c(0.8, 0.95))
cLUK2_0_MMZD_pred <- forecast(cLUK2_0_MMZD, h=P, level=c(0.8, 0.95))

cLUK2_0_tbats <- tbats(cLUK2_0)
cLUK2_0_tbats_pred <-forecast(cLUK2_0_tbats, h=P, level=c(0.8, 0.95))

cLUK2_0_ARIMA <- auto.arima(cLUK2_0,seasonal=FALSE)
cLUK2_0_ARIMA_pred <- forecast(cLUK2_0_ARIMA,P)


#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLUK2_0_AAN_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
##lines(cLUK3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLUK2_0_MMN_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
#lines(cLUK3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
##plot(cLUK2_0_AAND_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
#lines(cLUK3, col="red")
##abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLUK2_0_MMND_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
#lines(cLUK3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLUK2_0_tbats_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
#lines(cLUK3, col="red")
#abline(v=2020+75/365, col="green")

#par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
#plot(cLUK2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (UK))", ylim=c(0,20))
#lines(cLUK3, col="red")
#abline(v=2020+75/365, col="green")

```

```{r, echo=FALSE}
###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cLUK2_0, f_AANF, h=1, window=12)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cLUK2_0, f_MMNF, h=1, window=12)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cLUK2_0, f_AAND, h=1, window=12)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cLUK2_0, f_MMND, h=1, window=12)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cLUK2_0, f_TBATS, h=1, window=12)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cLUK2_0, f_ARIMA, h=1, window=12)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)
```


```{r, echo=FALSE}
#mean(abs(errors_AANF/cLUK2_0), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cLUK2_0), na.rm=TRUE)*100
#mean(abs(errors_AAND/cLUK2_0), na.rm=TRUE)*100
#mean(abs(errors_MMND/cLUK2_0), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cLUK2_0), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cLUK2_0), na.rm=TRUE)*100

```
Best model is ARIMA for UK:

```{r, echo=FALSE}

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cLUK2_0_ARIMA_pred, xlab="Time", ylab="log(Ac. deaths (FR))", ylim=c(0,20))
lines(cLUK3, col="red")
abline(v=2020+83/365, col="green")
```

So now let's plot this result in deaths over time

```{r, echo=FALSE}
expforeFRA_mean<-exp(cLUK2_0_ARIMA_pred$mean)

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(expforeFRA_mean, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,1e4))
abline(v=2020+83/365, col="green")
lines(cUK3, col="red")



```

Those exponential models can be a good prediction in the short term ie one week due to the delay in the incubation period of the virus although they are not good models for longer period such as one month.


## Predictions: 14 days after lockdown




We will further reproduce the same process for the 3 countries. Please note that we would note use the log in this phase as the data is no longer increasing exponentailly.

### Italy: 14 days after lockdown

```{r, echo=FALSE}

library(forecast)

####################
###ITALY ANALYSIS###
####################

t0=2020+53/365
P=15 #predicted days

cIT <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cIT_14 <- ts(covid_data$Cdeaths_IT[54:83],start=t0, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cIT_F <- ts(covid_data$Cdeaths_IT[54:148],start=t0, frequency=365)   # a supprimer 

cIT_14_AAN <- ets(cIT_14, model="AAN", damped=FALSE)
cIT_14_AAZ <- ets(cIT_14, model="AAZ", damped=FALSE)
cIT_14_MMN <- ets(cIT_14, model="MMN", damped=FALSE)
cIT_14_MMZ <- ets(cIT_14, model="MMZ", damped=FALSE)

cIT_14_AAND <- ets(cIT_14, model="AAN", damped=TRUE)
cIT_14_AAZD <- ets(cIT_14, model="AAZ", damped=TRUE)
cIT_14_MMND <- ets(cIT_14, model="MMN", damped=TRUE)
cIT_14_MMZD <- ets(cIT_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT_14_AAN_pred <- forecast(cIT_14_AAN, h=30, level=c(0.8, 0.95))
cIT_14_AAZ_pred <- forecast(cIT_14_AAZ, h=30, level=c(0.8, 0.95))
cIT_14_MMN_pred <- forecast(cIT_14_MMN, h=30, level=c(0.8, 0.95))
cIT_14_MMZ_pred <- forecast(cIT_14_MMZ, h=30, level=c(0.8, 0.95))

cIT_14_AAND_pred <- forecast(cIT_14_AAND, h=30, level=c(0.8, 0.95))
cIT_14_AAZD_pred <- forecast(cIT_14_AAZD, h=30, level=c(0.8, 0.95))
cIT_14_MMND_pred <- forecast(cIT_14_MMND, h=30, level=c(0.8, 0.95))
cIT_14_MMZD_pred <- forecast(cIT_14_MMZD, h=30, level=c(0.8, 0.95))

cIT_14_tbats <- tbats(cIT_14)
cIT_14_tbats_pred <-forecast(cIT_14_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cIT_14_ARIMA <- auto.arima(cIT_14,seasonal=FALSE)
cIT_14_ARIMA_pred <- forecast(cIT_14_ARIMA,30)



###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT_14, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT_14, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT_14, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT_14, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT_14, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT_14, f_ARIMA, h=1, window=15)

#mean(abs(errors_AANF/cIT_14), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cIT_14), na.rm=TRUE)*100
#mean(abs(errors_AAND/cIT_14), na.rm=TRUE)*100
#mean(abs(errors_MMND/cIT_14), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cIT_14), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cIT_14), na.rm=TRUE)*100

```
Based on the mean errors, we conclude that for Italy, the best model is the MMND model. 


```{r, echo=FALSE}

# Export the results out
write.csv(cIT_14_MMND_pred, file = "IT no lockdown+14d (MMND) .csv") # export the selected model's predictions into a CSV file

plot(cIT_14_MMND_pred, xlab="Year", ylab="Italy Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)


```


### France: 14 days after lockdown


```{r, echo=FALSE}
#####################
###France ANALYSIS###
####################


t0=2020+57/365
cFRA_14 <- ts(covid_data$Cdeaths_FRA[58:89],start=t0, frequency=365) #t=0 @ day75. +14d 
cFRA_F <- ts(covid_data$Cdeaths_FRA[58:148],start=t0, frequency=365)   # a supprimer?


cFRA_14_AAN <- ets(cFRA_14, model="AAN", damped=FALSE)
cFRA_14_AAZ <- ets(cFRA_14, model="AAZ", damped=FALSE)
cFRA_14_MMN <- ets(cFRA_14, model="MMN", damped=FALSE)
cFRA_14_MMZ <- ets(cFRA_14, model="MMZ", damped=FALSE)

cFRA_14_AAND <- ets(cFRA_14, model="AAN", damped=TRUE)
cFRA_14_AAZD <- ets(cFRA_14, model="AAZ", damped=TRUE)
cFRA_14_MMND <- ets(cFRA_14, model="MMN", damped=TRUE)
cFRA_14_MMZD <- ets(cFRA_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA_14_AAN_pred <- forecast(cFRA_14_AAN, h=30, level=c(0.8, 0.95))
cFRA_14_AAZ_pred <- forecast(cFRA_14_AAZ, h=30, level=c(0.8, 0.95))
cFRA_14_MMN_pred <- forecast(cFRA_14_MMN, h=30, level=c(0.8, 0.95))
cFRA_14_MMZ_pred <- forecast(cFRA_14_MMZ, h=30, level=c(0.8, 0.95))

cFRA_14_AAND_pred <- forecast(cFRA_14_AAND, h=30, level=c(0.8, 0.95))
cFRA_14_AAZD_pred <- forecast(cFRA_14_AAZD, h=30, level=c(0.8, 0.95))
cFRA_14_MMND_pred <- forecast(cFRA_14_MMND, h=30, level=c(0.8, 0.95))
cFRA_14_MMZD_pred <- forecast(cFRA_14_MMZD, h=30, level=c(0.8, 0.95))

cFRA_14_tbats <- tbats(cFRA_14)
cFRA_14_tbats_pred <-forecast(cFRA_14_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cFRA_14_ARIMA <- auto.arima(cFRA_14,seasonal=FALSE)
cFRA_14_ARIMA_pred <- forecast(cFRA_14_ARIMA,30)


###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA_14, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA_14, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA_14, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA_14, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA_14, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA_14, f_ARIMA, h=1, window=15)

#mean(abs(errors_AANF/cFRA_14), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cFRA_14), na.rm=TRUE)*100
#mean(abs(errors_AAND/cFRA_14), na.rm=TRUE)*100
#mean(abs(errors_MMND/cFRA_14), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cFRA_14), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cFRA_14), na.rm=TRUE)*100


```

Based on the mean errors, we conclude that for France the best model is the TBATS model


```{r, echo=FALSE}



# Export the results out
write.csv(cFRA_14_tbats_pred, file = "FRA no lockdown+14d (tbats) .csv") # export the selected model's predictions into a CSV file

plot(cFRA_14_tbats_pred, xlab="Year", ylab="France Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
abline(v=2020+75/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)



```


### UK: 14 days after lockdown

```{r, echo=FALSE}
#######################
#####UK Analysis#######
#######################


t0=2020+67/365

cUK_14 <- ts(covid_data$Cdeaths_UK[68:98],start=t0, frequency=365) #t=0 @ day84. +14d 
cUK_F <- ts(covid_data$Cdeaths_UK[68:148],start=t0, frequency=365)   # a supprimer?



cUK_14_AAN <- ets(cUK_14, model="AAN", damped=FALSE)
cUK_14_AAZ <- ets(cUK_14, model="AAZ", damped=FALSE)
cUK_14_MMN <- ets(cUK_14, model="MMN", damped=FALSE)
cUK_14_MMZ <- ets(cUK_14, model="MMZ", damped=FALSE)

cUK_14_AAND <- ets(cUK_14, model="AAN", damped=TRUE)
cUK_14_AAZD <- ets(cUK_14, model="AAZ", damped=TRUE)
cUK_14_MMND <- ets(cUK_14, model="MMN", damped=TRUE)
cUK_14_MMZD <- ets(cUK_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK_14_AAN_pred <- forecast(cUK_14_AAN, h=30, level=c(0.8, 0.95))
cUK_14_AAZ_pred <- forecast(cUK_14_AAZ, h=30, level=c(0.8, 0.95))
cUK_14_MMN_pred <- forecast(cUK_14_MMN, h=30, level=c(0.8, 0.95))
cUK_14_MMZ_pred <- forecast(cUK_14_MMZ, h=30, level=c(0.8, 0.95))

cUK_14_AAND_pred <- forecast(cUK_14_AAND, h=30, level=c(0.8, 0.95))
cUK_14_AAZD_pred <- forecast(cUK_14_AAZD, h=30, level=c(0.8, 0.95))
cUK_14_MMND_pred <- forecast(cUK_14_MMND, h=30, level=c(0.8, 0.95))
cUK_14_MMZD_pred <- forecast(cUK_14_MMZD, h=30, level=c(0.8, 0.95))

cUK_14_tbats <- tbats(cUK_14)
cUK_14_tbats_pred <-forecast(cUK_14_tbats, h=30, level=c(0.8, 0.95))


cUK_14_ARIMA <- auto.arima(cUK_14,seasonal=FALSE)
cUK_14_ARIMA_pred <- forecast(cUK_14_ARIMA,30)



###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK_14, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK_14, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK_14, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK_14, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK_14, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK_14, f_ARIMA, h=1, window=15)

#mean(abs(errors_AANF/cUK_14), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cUK_14), na.rm=TRUE)*100
#mean(abs(errors_AAND/cUK_14), na.rm=TRUE)*100
#mean(abs(errors_MMND/cUK_14), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cUK_14), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cUK_14), na.rm=TRUE)*100


```

Based on the mean errors, we conclude that for the UK the best model is the AAN model

```{r, echo=FALSE}


# Export the results out
write.csv(cUK_14_AAN_pred, file = "UK no lockdown+14d (AAN) .csv") # export the selected model's predictions into a CSV file

plot(cUK_14_AAN_pred, xlab="Year", ylab="UK Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
abline(v=2020+84/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)

```




## Predictions: 28 days after lockdown


We will further reproduce the same process for the 3 countries 28 days post the lockdown.We believe that it takes countries at leats 14 days to see the results of the lockdown, hence in these models we predict a lower deaths projections for all countries.  


### Italy: 28 days after lockdown

```{r, echo=FALSE}

library(forecast)

####################
###ITALY ANALYSIS###
####################

#covid_data<-read.csv(file.choose(), header=TRUE, sep=",")

t0=2020+53/365
P=15 #predicted days
#FRA <- ts(covid_data$deaths_IT,start=0, frequency=1)
cIT <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cIT_28 <- ts(covid_data$Cdeaths_IT[54:97],start=t0, frequency=365) #t=0 @ day69. +28d #before it was starting at 45
cIT_F <- ts(covid_data$Cdeaths_IT[54:288],start=t0, frequency=365)   # a supprimer 

#plot(cIT_F)
#lines(cIT_28, col="red")

cIT_28_AAN <- ets(cIT_28, model="AAN", damped=FALSE)
cIT_28_AAZ <- ets(cIT_28, model="AAZ", damped=FALSE)
cIT_28_MMN <- ets(cIT_28, model="MMN", damped=FALSE)
cIT_28_MMZ <- ets(cIT_28, model="MMZ", damped=FALSE)

cIT_28_AAND <- ets(cIT_28, model="AAN", damped=TRUE)
cIT_28_AAZD <- ets(cIT_28, model="AAZ", damped=TRUE)
cIT_28_MMND <- ets(cIT_28, model="MMN", damped=TRUE)
cIT_28_MMZD <- ets(cIT_28, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT_28_AAN_pred <- forecast(cIT_28_AAN, h=30, level=c(0.8, 0.95))
cIT_28_AAZ_pred <- forecast(cIT_28_AAZ, h=30, level=c(0.8, 0.95))
cIT_28_MMN_pred <- forecast(cIT_28_MMN, h=30, level=c(0.8, 0.95))
cIT_28_MMZ_pred <- forecast(cIT_28_MMZ, h=30, level=c(0.8, 0.95))

cIT_28_AAND_pred <- forecast(cIT_28_AAND, h=30, level=c(0.8, 0.95))
cIT_28_AAZD_pred <- forecast(cIT_28_AAZD, h=30, level=c(0.8, 0.95))
cIT_28_MMND_pred <- forecast(cIT_28_MMND, h=30, level=c(0.8, 0.95))
cIT_28_MMZD_pred <- forecast(cIT_28_MMZD, h=30, level=c(0.8, 0.95))

cIT_28_tbats <- tbats(cIT_28)
cIT_28_tbats_pred <-forecast(cIT_28_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cIT_28_ARIMA <- auto.arima(cIT_28,seasonal=FALSE)
cIT_28_ARIMA_pred <- forecast(cIT_28_ARIMA,30)


###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT_28, f_AANF, h=1, window=25)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT_28, f_MMNF, h=1, window=25)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT_28, f_AAND, h=1, window=25)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT_28, f_MMND, h=1, window=25)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT_28, f_TBATS, h=1, window=25)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT_28, f_ARIMA, h=1, window=25)


#mean(abs(errors_AANF/cIT_28), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cIT_28), na.rm=TRUE)*100
#mean(abs(errors_AAND/cIT_28), na.rm=TRUE)*100
#mean(abs(errors_MMND/cIT_28), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cIT_28), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cIT_28), na.rm=TRUE)*100

```
Based on the mean errors, we conclude that for Italy, the best model is the AAN model. 


```{r, echo=FALSE}

# Export the results out
write.csv(cIT_28_AAN_pred, file = "IT no lockdown+28d (AAN) .csv") # export the selected model's predictions into a CSV file

plot(cIT_28_AAN_pred, xlab="Year", ylab="Italy Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)


```


### France: 28 days after lockdown


```{r, echo=FALSE}
#####################
###France ANALYSIS###
####################


t0=2020+57/365

cFRA_28 <- ts(covid_data$Cdeaths_FRA[58:103],start=t0, frequency=365) #t=0 @ day75. +28d 
cFRA_F <- ts(covid_data$Cdeaths_FRA[58:288],start=t0, frequency=365)   # a supprimer?

cFRA_28_AAN <- ets(cFRA_28, model="AAN", damped=FALSE)
cFRA_28_AAZ <- ets(cFRA_28, model="AAZ", damped=FALSE)
cFRA_28_MMN <- ets(cFRA_28, model="MMN", damped=FALSE)
cFRA_28_MMZ <- ets(cFRA_28, model="MMZ", damped=FALSE)

cFRA_28_AAND <- ets(cFRA_28, model="AAN", damped=TRUE)
cFRA_28_AAZD <- ets(cFRA_28, model="AAZ", damped=TRUE)
cFRA_28_MMND <- ets(cFRA_28, model="MMN", damped=TRUE)
cFRA_28_MMZD <- ets(cFRA_28, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA_28_AAN_pred <- forecast(cFRA_28_AAN, h=30, level=c(0.8, 0.95))
cFRA_28_AAZ_pred <- forecast(cFRA_28_AAZ, h=30, level=c(0.8, 0.95))
cFRA_28_MMN_pred <- forecast(cFRA_28_MMN, h=30, level=c(0.8, 0.95))
cFRA_28_MMZ_pred <- forecast(cFRA_28_MMZ, h=30, level=c(0.8, 0.95))

cFRA_28_AAND_pred <- forecast(cFRA_28_AAND, h=30, level=c(0.8, 0.95))
cFRA_28_AAZD_pred <- forecast(cFRA_28_AAZD, h=30, level=c(0.8, 0.95))
cFRA_28_MMND_pred <- forecast(cFRA_28_MMND, h=30, level=c(0.8, 0.95))
cFRA_28_MMZD_pred <- forecast(cFRA_28_MMZD, h=30, level=c(0.8, 0.95))

cFRA_28_tbats <- tbats(cFRA_28)
cFRA_28_tbats_pred <-forecast(cFRA_28_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))
#plot(cFRA_28_tbats_pred, xlab="Year", ylab="Predicted Electric Rate")
#lines(cFRA_F, col="red")

cFRA_28_ARIMA <- auto.arima(cFRA_28,seasonal=FALSE)
cFRA_28_ARIMA_pred <- forecast(cFRA_28_ARIMA,30)

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA_28, f_AANF, h=1, window=25)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA_28, f_MMNF, h=1, window=25)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA_28, f_AAND, h=1, window=25)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA_28, f_MMND, h=1, window=25)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA_28, f_TBATS, h=1, window=25)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA_28, f_ARIMA, h=1, window=25)


#mean(abs(errors_AANF/cFRA_28), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cFRA_28), na.rm=TRUE)*100
#mean(abs(errors_AAND/cFRA_28), na.rm=TRUE)*100
#mean(abs(errors_MMND/cFRA_28), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cFRA_28), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cFRA_28), na.rm=TRUE)*100


```

Based on the mean errors, we conclude that for France the best model is the tbats model


```{r, echo=FALSE}


# Export the results out
write.csv(cFRA_28_tbats_pred, file = "FRA no lockdown+28d (tbats) .csv") # export the selected model's predictions into a CSV file

plot(cFRA_28_tbats_pred, xlab="Year", ylab="France Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
abline(v=2020+75/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)



```


### uk: 28 days after lockdown

```{r, echo=FALSE}
#######################
#####UK Analysis#######
#######################


t0=2020+67/365
cUK_28 <- ts(covid_data$Cdeaths_UK[68:112],start=t0, frequency=365) #t=0 @ day84. +28d 
cUK_F <- ts(covid_data$Cdeaths_UK[68:288],start=t0, frequency=365)   # a supprimer?

#plot(cUK_F)
#lines(cUK_28, col="red")

cUK_28_AAN <- ets(cUK_28, model="AAN", damped=FALSE)
cUK_28_AAZ <- ets(cUK_28, model="AAZ", damped=FALSE)
cUK_28_MMN <- ets(cUK_28, model="MMN", damped=FALSE)
cUK_28_MMZ <- ets(cUK_28, model="MMZ", damped=FALSE)

cUK_28_AAND <- ets(cUK_28, model="AAN", damped=TRUE)
cUK_28_AAZD <- ets(cUK_28, model="AAZ", damped=TRUE)
cUK_28_MMND <- ets(cUK_28, model="MMN", damped=TRUE)
cUK_28_MMZD <- ets(cUK_28, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK_28_AAN_pred <- forecast(cUK_28_AAN, h=30, level=c(0.8, 0.95))
cUK_28_AAZ_pred <- forecast(cUK_28_AAZ, h=30, level=c(0.8, 0.95))
cUK_28_MMN_pred <- forecast(cUK_28_MMN, h=30, level=c(0.8, 0.95))
cUK_28_MMZ_pred <- forecast(cUK_28_MMZ, h=30, level=c(0.8, 0.95))

cUK_28_AAND_pred <- forecast(cUK_28_AAND, h=30, level=c(0.8, 0.95))
cUK_28_AAZD_pred <- forecast(cUK_28_AAZD, h=30, level=c(0.8, 0.95))
cUK_28_MMND_pred <- forecast(cUK_28_MMND, h=30, level=c(0.8, 0.95))
cUK_28_MMZD_pred <- forecast(cUK_28_MMZD, h=30, level=c(0.8, 0.95))

cUK_28_tbats <- tbats(cUK_28)
cUK_28_tbats_pred <-forecast(cUK_28_tbats, h=30, level=c(0.8, 0.95))


cUK_28_ARIMA <- auto.arima(cUK_28,seasonal=FALSE)
cUK_28_ARIMA_pred <- forecast(cUK_28_ARIMA,30)


###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK_28, f_AANF, h=1, window=25)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK_28, f_MMNF, h=1, window=25)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK_28, f_AAND, h=1, window=25)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK_28, f_MMND, h=1, window=25)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK_28, f_TBATS, h=1, window=25)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK_28, f_ARIMA, h=1, window=25)


#mean(abs(errors_AANF/cUK_28), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cUK_28), na.rm=TRUE)*100
#mean(abs(errors_AAND/cUK_28), na.rm=TRUE)*100
#mean(abs(errors_MMND/cUK_28), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cUK_28), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cUK_28), na.rm=TRUE)*100

```

Based on the mean errors, we conclude that for the UK the best model is the ARIMA model

```{r, echo=FALSE}


# Export the results out
write.csv(cUK_28_ARIMA_pred, file = "UK no lockdown+28d (Arima) .csv") # export the selected model's predictions into a CSV file

plot(cUK_28_ARIMA_pred, xlab="Year", ylab="UK Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
abline(v=2020+84/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)

```


## Predictions 56 days after lockdown 


We will further reproduce the same process for the 3 countries 56 days post the lockdown. We are interested in analyzing the evolution of deaths in the last 14 days, based on the available data, to assess per country the effectiveness of the lockdown.


### Italy: 56 days after lockdown  

```{r, echo=FALSE}

library(forecast)

####################
###ITALY ANALYSIS###
####################


t0=2020+53/365
P=15 #predicted days

cIT <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cIT_56 <- ts(covid_data$Cdeaths_IT[54:125],start=t0, frequency=365) #t=0 @ day69. +56d #before it was starting at 45
cIT_F <- ts(covid_data$Cdeaths_IT[54:288],start=t0, frequency=365)   # a supprimer 



cIT_56_AAN <- ets(cIT_56, model="AAN", damped=FALSE)
cIT_56_AAZ <- ets(cIT_56, model="AAZ", damped=FALSE)
cIT_56_MMN <- ets(cIT_56, model="MMN", damped=FALSE)
cIT_56_MMZ <- ets(cIT_56, model="MMZ", damped=FALSE)

cIT_56_AAND <- ets(cIT_56, model="AAN", damped=TRUE)
cIT_56_AAZD <- ets(cIT_56, model="AAZ", damped=TRUE)
cIT_56_MMND <- ets(cIT_56, model="MMN", damped=TRUE)
cIT_56_MMZD <- ets(cIT_56, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT_56_AAN_pred <- forecast(cIT_56_AAN, h=30, level=c(0.8, 0.95))
cIT_56_AAZ_pred <- forecast(cIT_56_AAZ, h=30, level=c(0.8, 0.95))
cIT_56_MMN_pred <- forecast(cIT_56_MMN, h=30, level=c(0.8, 0.95))
cIT_56_MMZ_pred <- forecast(cIT_56_MMZ, h=30, level=c(0.8, 0.95))

cIT_56_AAND_pred <- forecast(cIT_56_AAND, h=30, level=c(0.8, 0.95))
cIT_56_AAZD_pred <- forecast(cIT_56_AAZD, h=30, level=c(0.8, 0.95))
cIT_56_MMND_pred <- forecast(cIT_56_MMND, h=30, level=c(0.8, 0.95))
cIT_56_MMZD_pred <- forecast(cIT_56_MMZD, h=30, level=c(0.8, 0.95))

cIT_56_tbats <- tbats(cIT_56)
cIT_56_tbats_pred <-forecast(cIT_56_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cIT_56_ARIMA <- auto.arima(cIT_56,seasonal=FALSE)
cIT_56_ARIMA_pred <- forecast(cIT_56_ARIMA,30)


###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT_56, f_AANF, h=1, window=45)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT_56, f_MMNF, h=1, window=45)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT_56, f_AAND, h=1, window=45)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT_56, f_MMND, h=1, window=45)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT_56, f_TBATS, h=1, window=45)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT_56, f_ARIMA, h=1, window=45)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

#mean(abs(errors_AANF/cIT_56), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cIT_56), na.rm=TRUE)*100
#mean(abs(errors_AAND/cIT_56), na.rm=TRUE)*100
#mean(abs(errors_MMND/cIT_56), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cIT_56), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cIT_56), na.rm=TRUE)*100
```
Based on the mean errors, we conclude that for Italy, the best model is the TBATS model. 


```{r, echo=FALSE}

# Export the results out
write.csv(cIT_56_tbats_pred, file = "IT no lockdown+56d (tbats) .csv") # export the selected model's predictions into a CSV file

plot(cIT_56_tbats_pred, xlab="Year", ylab="Italy Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)


```


### France: 56 days after lockdown

```{r, echo=FALSE}
#####################
###France ANALYSIS###
####################


t0=2020+57/365

cFRA_56 <- ts(covid_data$Cdeaths_FRA[58:131],start=t0, frequency=365) #t=0 @ day75. +56d 
cFRA_F <- ts(covid_data$Cdeaths_FRA[58:288],start=t0, frequency=365)   # a supprimer?



cFRA_56_AAN <- ets(cFRA_56, model="AAN", damped=FALSE)
cFRA_56_AAZ <- ets(cFRA_56, model="AAZ", damped=FALSE)
cFRA_56_MMN <- ets(cFRA_56, model="MMN", damped=FALSE)
cFRA_56_MMZ <- ets(cFRA_56, model="MMZ", damped=FALSE)

cFRA_56_AAND <- ets(cFRA_56, model="AAN", damped=TRUE)
cFRA_56_AAZD <- ets(cFRA_56, model="AAZ", damped=TRUE)
cFRA_56_MMND <- ets(cFRA_56, model="MMN", damped=TRUE)
cFRA_56_MMZD <- ets(cFRA_56, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA_56_AAN_pred <- forecast(cFRA_56_AAN, h=30, level=c(0.8, 0.95))
cFRA_56_AAZ_pred <- forecast(cFRA_56_AAZ, h=30, level=c(0.8, 0.95))
cFRA_56_MMN_pred <- forecast(cFRA_56_MMN, h=30, level=c(0.8, 0.95))
cFRA_56_MMZ_pred <- forecast(cFRA_56_MMZ, h=30, level=c(0.8, 0.95))

cFRA_56_AAND_pred <- forecast(cFRA_56_AAND, h=30, level=c(0.8, 0.95))
cFRA_56_AAZD_pred <- forecast(cFRA_56_AAZD, h=30, level=c(0.8, 0.95))
cFRA_56_MMND_pred <- forecast(cFRA_56_MMND, h=30, level=c(0.8, 0.95))
cFRA_56_MMZD_pred <- forecast(cFRA_56_MMZD, h=30, level=c(0.8, 0.95))

cFRA_56_tbats <- tbats(cFRA_56)
cFRA_56_tbats_pred <-forecast(cFRA_56_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cFRA_56_ARIMA <- auto.arima(cFRA_56,seasonal=FALSE)
cFRA_56_ARIMA_pred <- forecast(cFRA_56_ARIMA,30)

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA_56, f_AANF, h=1, window=65)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA_56, f_MMNF, h=1, window=65)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA_56, f_AAND, h=1, window=65)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA_56, f_MMND, h=1, window=65)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA_56, f_TBATS, h=1, window=65)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA_56, f_ARIMA, h=1, window=65)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

#mean(abs(errors_AANF/cFRA_56), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cFRA_56), na.rm=TRUE)*100
#mean(abs(errors_AAND/cFRA_56), na.rm=TRUE)*100
#mean(abs(errors_MMND/cFRA_56), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cFRA_56), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cFRA_56), na.rm=TRUE)*100

```

Based on the mean errors, we conclude that for France the best model is the TBATS model


```{r, echo=FALSE}


# Export the results out
write.csv(cFRA_56_tbats_pred, file = "FRA no lockdown+56d (tbats) .csv") # export the selected model's predictions into a CSV file

plot(cFRA_56_tbats_pred, xlab="Year", ylab="France Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
abline(v=2020+75/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)



```


### UK: 56 days after lockdown
```{r, echo=FALSE}
#######################
#####UK Analysis#######
#######################


t0=2020+67/365
cUK_56 <- ts(covid_data$Cdeaths_UK[68:140],start=t0, frequency=365) #t=0 @ day84. +56d 
cUK_F <- ts(covid_data$Cdeaths_UK[68:288],start=t0, frequency=365)   # a supprimer?


cUK_56_AAN <- ets(cUK_56, model="AAN", damped=FALSE)
cUK_56_AAZ <- ets(cUK_56, model="AAZ", damped=FALSE)
cUK_56_MMN <- ets(cUK_56, model="MMN", damped=FALSE)
cUK_56_MMZ <- ets(cUK_56, model="MMZ", damped=FALSE)

cUK_56_AAND <- ets(cUK_56, model="AAN", damped=TRUE)
cUK_56_AAZD <- ets(cUK_56, model="AAZ", damped=TRUE)
cUK_56_MMND <- ets(cUK_56, model="MMN", damped=TRUE)
cUK_56_MMZD <- ets(cUK_56, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK_56_AAN_pred <- forecast(cUK_56_AAN, h=30, level=c(0.8, 0.95))
cUK_56_AAZ_pred <- forecast(cUK_56_AAZ, h=30, level=c(0.8, 0.95))
cUK_56_MMN_pred <- forecast(cUK_56_MMN, h=30, level=c(0.8, 0.95))
cUK_56_MMZ_pred <- forecast(cUK_56_MMZ, h=30, level=c(0.8, 0.95))

cUK_56_AAND_pred <- forecast(cUK_56_AAND, h=30, level=c(0.8, 0.95))
cUK_56_AAZD_pred <- forecast(cUK_56_AAZD, h=30, level=c(0.8, 0.95))
cUK_56_MMND_pred <- forecast(cUK_56_MMND, h=30, level=c(0.8, 0.95))
cUK_56_MMZD_pred <- forecast(cUK_56_MMZD, h=30, level=c(0.8, 0.95))

cUK_56_tbats <- tbats(cUK_56)
cUK_56_tbats_pred <-forecast(cUK_56_tbats, h=30, level=c(0.8, 0.95))


cUK_56_ARIMA <- auto.arima(cUK_56,seasonal=FALSE)
cUK_56_ARIMA_pred <- forecast(cUK_56_ARIMA,30)



###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK_56, f_AANF, h=1, window=65)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK_56, f_MMNF, h=1, window=65)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK_56, f_AAND, h=1, window=65)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK_56, f_MMND, h=1, window=65)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK_56, f_TBATS, h=1, window=65)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK_56, f_ARIMA, h=1, window=65)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

#mean(abs(errors_AANF/cUK_56), na.rm=TRUE)*100
#mean(abs(errors_MMNF/cUK_56), na.rm=TRUE)*100
#mean(abs(errors_AAND/cUK_56), na.rm=TRUE)*100
#mean(abs(errors_MMND/cUK_56), na.rm=TRUE)*100
#mean(abs(errors_TBATS/cUK_56), na.rm=TRUE)*100
#mean(abs(errors_ARIMA/cUK_56), na.rm=TRUE)*100

```

Based on the mean errors, we conclude that for the UK the best model is the TBATS model

```{r, echo=FALSE}


# Export the results out
write.csv(cUK_56_tbats_pred, file = "UK no lockdown+56d (tbats) .csv") # export the selected model's predictions into a CSV file

plot(cUK_56_tbats_pred, xlab="Year", ylab="UK Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
abline(v=2020+84/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)

```



# 4. Conclusion

By looking at the predicion models, we see that France has adopted the best approach in comparison with Italy and United Kingdom. 
Helped by the Italian experience, France has pronounced the lockdown before reach a very damageable tipping point. The predicting curve of martality rate at Lockdown date suggests that Italy had taken the least effective measures. 

This analysis is confirmed with the post-14 days observations that assess the real impact of the lockdown after the incubation period. 

Finally, the post-56 days data shows that UK is in the worst situation as the curve of infection is still very steep. In terms of business implication, it also means that UK might have to wait longer than France and Italy to deconfine. 
This conclusion sounds quite logical as the virus spread was exponential. Therefore, the longer a country has waited to pronounce the confinement, the more spread was the virus with the multiplicative consequences it engenders, and the longer it will take to stop the contamination. 

Overall, from an economic perspective, UK might have more to lose by havong waited longer to pronounce lockdown while Italy and France are in better position to relaunch their economy. 

Nevertheless, the analysis presents some limitations as we have not taken into account some factors such as the density of the population, nor segmented countries into areas at different level of contamination risks. The stringency of the lockdown has been assumed
Moreover, economic or political terms have not been taken into account in our analaysis. Indeed, the Brexit and tense political situation might have pushed UK's government to defer the confinement date in order to diminish the economic impact of the covid-19. In France, the confinement has been announced just after political vote. 
