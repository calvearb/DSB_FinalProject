---
title: "Evaluation of lock-down effect in several European countries"
author: "M. Noujaim, Q. Shi, M. Parashar, A. Bouzid, C. Alvear"
output:
  html_document:
    theme: paper
    toc: yes
    toc_float:
      collapsed: no
      smooth_scroll: yes
  pdf_document:
    includes:
always_allow_html: yes
---

<!-- **Note:** Assuming the working directory is "MYDIRECTORY/INSEADAnalytics" (where you have cloned the course material), you can create an html file by running in your console the command (pay attention to the directory you are in, check it using getwd()) rmarkdown::render("CourseSessions/InClassProcess/MarketSegmentationProcessInClass.Rmd") -->


<hr>\clearpage
 

# Introduction

The unfolding, global COVID-19 pandemic is a human crisis of historic scale and complexity. It is straining healthcare systems, government financial capabilities, and the ability of many organizations to cope with the changes wrought by the virus and the response to it. The level of uncertainty for most leaders has been unprecedented, and most of our frameworks for planning and problem solving were unable to manage the geographic variability, uncertainty, and the exponential change brought by the COVID-19 crisis.

Government decisions for lockdown were mainly made by compromising between healthcare capabilities and economic disaster. The timing of governements' initiatives were often ambiguous and have been constantly being revised. 

Mitigate the econonomic impact of the Covid-19 and assess the stringency level of confinement have finally pushed governments to pronounce lockdowns at different moments. 
If all countries lacked experience in maganing such a crisis, Italian lockdown decision was taken after patient 0 was discovered and after what we commonly call a "tipping point", that is when the virus had already spread fast. French decision was taken a week after Italy. Finally, United Kingdom, in political and economic trouble due to the Brexit situation, waited a week more than France to announce the confinement. 

How did those delays affected the spread of the virus and mortality?
How long should be the lockdown period in each country and ultimately which country has best managed the situation?  

We will then compare countries to one another and evaluate how the timing of public policy decisions (Lockdown) has affected the control of the Covid-19 pandemic spread.

<hr>\clearpage

# The Project Initiative

The project aims at analyzing the effect of the lockdown policies in Italy, France and United Kingdom and then observe the change in the mortality curve predictions. 
We will put ourselves in the shoes of Government decision makers at different dates and analyze the public data available to come up with predictive models of mortality. We will create several time-series models to predict the cumulative deaths with the information at the lockdown date, 14 days, 28 days and 56 days later.

<hr>\clearpage

# The Process

The project methodology is a time-series modeling and implementation to evaluate future mortality. 

Firstly, we want to see how was the situation when the Lockdown was decided. 
For instance, in the case of Italy, the deaths before the lockdown (until March 9th 2020) were already growing at an exponential rate. So we would first like to see how was the prediction this day and estimate how many lives were saved thanks to the lockdown imposition by comparing the prediciton with the actual data.

Secondly, because the virus can incubate for up to 2 weeks before the first symptoms appear, we will also look at the prediction 14 days after the Lockdown decision. With more data available but without the direct impact of the Lockdown (due to the incubation period), this model should have narrower and more accurate confidence interval.  The first two dates will compare early predictions with the real death toll to know how many lives were saved and how the virus contamination was slowed down in each country.

Nevertheless, both first models would note take into account the lockdown effect, which should drastically change the spread of the virus and so further predictions. To do so, we would look at prediction 28 days after the lockdown start which should help measuring the assumed positive effect of lockdown. 

Finally, the latest prediction, being done 8 weeks after the lockdown date with the latest data available (May 25th), should be a good indicator of the current situation of the crisis and of the level of control and certainty about the pandemic evolution. This will give us insights on how the delay in lockdown dates for each country has affected the spread curve of the Coronavirus over 8 weeks. It will ultimately indicate whether lockdown shall be ended or pursued.

At the end of the process, we will be able to compare different lockdown impacts on mortality predictions and will determine which countries are in good position for ending the lockdown. Considering end of confinement also means economy restart, it would also give us a sense of which lockdown and stringency policy decisions were the most effective from an economic perspective. Indeed, the earlier the end of lockdown, the better for the economy. 

## The Data Set 

The data set is extracted from the Covid-19 official Europe Data Website (source:https://data.europa.eu/euodp/en/data/dataset/covid-19-coronavirus-data)
It contains the 2020 daily evolution of Deaths and confirmed cases by country. 

We will start by importing the dataset 

## Timeseries Dataframe
The timeseries starting point will always be the day in which the first death was recensed for each country. In the case of Italy, first death was on February 23rd January 2020, (day 54 of 2020 - Line 55 of the dataset). 
Reference Start Day will be considered January 1,2020 as we do not have data for 2019 in the selected countries. 
For time series, a minimum of periods is needed to perform analysis, so we reduced the frequency to days instead of months or years because Covid-19 is very new so we could not have yearly nor monthly background. 

The below graphs show the real data given by the official Covid-19 Europe Data Webiste till May 25th, 2020.
The vertical green line represents the lockdown date in the country (For Italy it is March 9th which is 65 days after January 1,2020). 
The red data line refers to the data we will take into account for predicting future mortality. This interval will change depending on the date in which we analyze the data. For instance, to perform the prediction at the lockdown date, we will take into account all date between the first death till the lockdown date. 
The black line is the real death toll of the country given by the official Covid-19 Europe Data Webiste till May 25th, 2020.

This timesieries process will be updated by date and countries before performing different timeseries models in order to assess the most accurate prediction model. 

## Prediction Methodology 
We will perform different types of timeseries models:

### Exponential Smoothing
4 models of Exponential Smoothing ETS with and without dampening: AAN, MMN, AMND, MMND 
The death curve is cumulative and so there will be no seasonality. Therefore, the timeseries models with Z should not be useful. 

### TBATS
Decomposition model trigonometric TBATS. TBATS will become BATS because of no seasonality so no need for trigonomectric adjustment. 

### Auto-regressive Method ARIMA

We will finally select the model that fits the best for the first country and will further reproduce the same process other countries. Finally we will present 3 best plots for each country

For reading purpose, we will only present the comprehensive process for Italy at Lockdown. We will only present the results of the best plot for others countries and other dates with some comments. 

## At lockdown Date 







## Import the data set 

```{r, echo=FALSE}
echo=FALSE
covid_data <- read.csv("COVID_data_v3.csv", header=TRUE, sep=",")
#ProjectData <- data.matrix(ProjectData) 
#ProjectData_INITIAL <- ProjectData

t0_IT=2020+53/365 #day of first casualty
P=15 #predicted days
cIT2_0 <- ts((covid_data$Cdeaths_IT[54:69]),start=t0_IT, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cIT3 <- ts((covid_data$Cdeaths_IT[54:146]),start=t0_IT, frequency=365)

plot(cIT3, xlab="Time", ylab="Accumulated deaths (Italy)")
lines(cIT2_0, col="red")
abline(v=2020+69/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)



#French Data
t0_FR <- 2020+46/365
cFRA2_0 <- ts(covid_data$Cdeaths_FRA[46:75],start=t0_FR, frequency=365) #t=0 @ day75, March 15th #before it was starting at 45
cFRA3 <- ts(covid_data$Cdeaths_FRA[46:146],start=t0_FR, frequency=365)

plot(cFRA3, xlab="Time", ylab="Accumulated deaths (France)")
lines(cFRA2_0, col="red")
abline(v=2020+75/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)


#UK Data

t0_UK=2020+67/365
cUK2_0 <- ts(covid_data$Cdeaths_UK[67:83],start=t0_UK, frequency=365) #t=0 @ day83. +0d
cUK3 <- ts(covid_data$Cdeaths_UK[67:146],start=t0_UK, frequency=365)

plot(cUK3, xlab="Time", ylab="Accumulated deaths (UK)")
lines(cUK2_0, col="red")
abline(v=2020+83/365, col="green")
legend("bottomright", legend=c("Real death toll","Data to use", "Start of Lockdown(d=0)"), col=c("blue", "red","green"), lty=1)


```



### At Lock Down Date 
#### Italy at Lock Down Date
```{r, echo=FALSE}
library(forecast)
#Italy
cIT2_0_AAN <- ets(cIT2_0, model="AAN", damped=FALSE)
cIT2_0_AAZ <- ets(cIT2_0, model="AAZ", damped=FALSE)
cIT2_0_MMN <- ets(cIT2_0, model="MMN", damped=FALSE)
cIT2_0_MMZ <- ets(cIT2_0, model="MMZ", damped=FALSE)

cIT2_0_AAND <- ets(cIT2_0, model="AAN", damped=TRUE)
cIT2_0_AAZD <- ets(cIT2_0, model="AAZ", damped=TRUE)
cIT2_0_MMND <- ets(cIT2_0, model="MMN", damped=TRUE)
cIT2_0_MMZD <- ets(cIT2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT2_0_AAN_pred <- forecast(cIT2_0_AAN, h=P, level=c(0.8, 0.95))
cIT2_0_AAZ_pred <- forecast(cIT2_0_AAZ, h=P, level=c(0.8, 0.95))
cIT2_0_MMN_pred <- forecast(cIT2_0_MMN, h=P, level=c(0.8, 0.95))
cIT2_0_MMZ_pred <- forecast(cIT2_0_MMZ, h=P, level=c(0.8, 0.95))

cIT2_0_AAND_pred <- forecast(cIT2_0_AAND, h=P, level=c(0.8, 0.95))
cIT2_0_AAZD_pred <- forecast(cIT2_0_AAZD, h=P, level=c(0.8, 0.95))
cIT2_0_MMND_pred <- forecast(cIT2_0_MMND, h=P, level=c(0.8, 0.95))
cIT2_0_MMZD_pred <- forecast(cIT2_0_MMZD, h=P, level=c(0.8, 0.95))

cIT2_0_tbats <- tbats(cIT2_0)
cIT2_0_tbats_pred <-forecast(cIT2_0_tbats, h=30, level=c(0.8, 0.95))

cIT2_0_ARIMA <- auto.arima(cIT2_0,seasonal=FALSE)
cIT2_0_ARIMA_pred <- forecast(cIT2_0_ARIMA,P)

par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT2_0_AAN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_AAZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT2_0_AAND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_AAZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
plot(cIT2_0_MMZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (Italy)")
lines(cIT3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (Italy)")
lines(cIT3, col="red")


```

```{r}

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMNF/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_AAND/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_MMND/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_TBATS/cIT2_0), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cIT2_0), na.rm=TRUE)*100

```
Best model is MMNF for Italy:

```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cIT2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (Italy)", ylim=c(0,10000))
lines(cIT3, col="red")
```


#### France at Lock Down Date

```{r, echo=FALSE}
library(forecast)
#Italy
cFRA2_0_AAN <- ets(cFRA2_0, model="AAN", damped=FALSE)
cFRA2_0_AAZ <- ets(cFRA2_0, model="AAZ", damped=FALSE)
cFRA2_0_MMN <- ets(cFRA2_0, model="MMN", damped=FALSE)
cFRA2_0_MMZ <- ets(cFRA2_0, model="MMZ", damped=FALSE)

cFRA2_0_AAND <- ets(cFRA2_0, model="AAN", damped=TRUE)
cFRA2_0_AAZD <- ets(cFRA2_0, model="AAZ", damped=TRUE)
cFRA2_0_MMND <- ets(cFRA2_0, model="MMN", damped=TRUE)
cFRA2_0_MMZD <- ets(cFRA2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA2_0_AAN_pred <- forecast(cFRA2_0_AAN, h=P, level=c(0.8, 0.95))
cFRA2_0_AAZ_pred <- forecast(cFRA2_0_AAZ, h=P, level=c(0.8, 0.95))
cFRA2_0_MMN_pred <- forecast(cFRA2_0_MMN, h=P, level=c(0.8, 0.95))
cFRA2_0_MMZ_pred <- forecast(cFRA2_0_MMZ, h=P, level=c(0.8, 0.95))

cFRA2_0_AAND_pred <- forecast(cFRA2_0_AAND, h=P, level=c(0.8, 0.95))
cFRA2_0_AAZD_pred <- forecast(cFRA2_0_AAZD, h=P, level=c(0.8, 0.95))
cFRA2_0_MMND_pred <- forecast(cFRA2_0_MMND, h=P, level=c(0.8, 0.95))
cFRA2_0_MMZD_pred <- forecast(cFRA2_0_MMZD, h=P, level=c(0.8, 0.95))

cFRA2_0_tbats <- tbats(cFRA2_0)
cFRA2_0_tbats_pred <-forecast(cFRA2_0_tbats, h=30, level=c(0.8, 0.95))

cFRA2_0_ARIMA <- auto.arima(cFRA2_0,seasonal=FALSE)
cFRA2_0_ARIMA_pred <- forecast(cFRA2_0_ARIMA,P)


par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (FR)")
lines(cFRA3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (FR)")
lines(cFRA3, col="red")


```

```{r}

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cFRA2_0), na.rm=TRUE)*100
mean(abs(errors_MMNF/cFRA2_0), na.rm=TRUE)*100
mean(abs(errors_AAND/cFRA2_0), na.rm=TRUE)*100
mean(abs(errors_MMND/cFRA2_0), na.rm=TRUE)*100
mean(abs(errors_TBATS/cFRA2_0), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cFRA2_0), na.rm=TRUE)*100

```
Best model is TBATS for France:

```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cFRA2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (FR)", ylim=c(0,10000))
lines(cFRA3, col="red")
```



#### UK at Lock Down Date

```{r, echo=FALSE}
library(forecast)
#Italy
cUK2_0_AAN <- ets(cUK2_0, model="AAN", damped=FALSE)
cUK2_0_AAZ <- ets(cUK2_0, model="AAZ", damped=FALSE)
cUK2_0_MMN <- ets(cUK2_0, model="MMN", damped=FALSE)
cUK2_0_MMZ <- ets(cUK2_0, model="MMZ", damped=FALSE)

cUK2_0_AAND <- ets(cUK2_0, model="AAN", damped=TRUE)
cUK2_0_AAZD <- ets(cUK2_0, model="AAZ", damped=TRUE)
cUK2_0_MMND <- ets(cUK2_0, model="MMN", damped=TRUE)
cUK2_0_MMZD <- ets(cUK2_0, model="MMZ", damped=TRUE)


# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK2_0_AAN_pred <- forecast(cUK2_0_AAN, h=P, level=c(0.8, 0.95))
cUK2_0_AAZ_pred <- forecast(cUK2_0_AAZ, h=P, level=c(0.8, 0.95))
cUK2_0_MMN_pred <- forecast(cUK2_0_MMN, h=P, level=c(0.8, 0.95))
cUK2_0_MMZ_pred <- forecast(cUK2_0_MMZ, h=P, level=c(0.8, 0.95))

cUK2_0_AAND_pred <- forecast(cUK2_0_AAND, h=P, level=c(0.8, 0.95))
cUK2_0_AAZD_pred <- forecast(cUK2_0_AAZD, h=P, level=c(0.8, 0.95))
cUK2_0_MMND_pred <- forecast(cUK2_0_MMND, h=P, level=c(0.8, 0.95))
cUK2_0_MMZD_pred <- forecast(cUK2_0_MMZD, h=P, level=c(0.8, 0.95))

cUK2_0_tbats <- tbats(cUK2_0)
cUK2_0_tbats_pred <-forecast(cUK2_0_tbats, h=30, level=c(0.8, 0.95))

cUK2_0_ARIMA <- auto.arima(cUK2_0,seasonal=FALSE)
cUK2_0_ARIMA_pred <- forecast(cUK2_0_ARIMA,P)

#par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
#plot(cUK2_0_AAN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMN_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_AAZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMZ_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

#par(mfrow=c(2,2)) # This command sets the plot window to show 1 row of 4 plots
#plot(cUK2_0_AAND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMND_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_AAZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))
#plot(cUK2_0_MMZD_pred, xlab="Year", ylab="Ac. deaths", ylim=c(0,10000))

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_AAN_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_MMN_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_AAND_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_MMND_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (UK)")
lines(cUK3, col="red")

par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_ARIMA_pred, xlab="Time", ylab="Ac. deaths (UK)")
lines(cUK3, col="red")


```

```{r}

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK2_0, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK2_0, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK2_0, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK2_0, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK2_0, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK2_0, f_ARIMA, h=1, window=15)


#par(mfrow=c(1,1)) 
#plot(errors_AANF, ylab='tsCV errors')
#abline(0,0)
#lines(errors_MMNF, col="red")
#lines(errors_AAND, col="green")
#lines(errors_MMND, col="blue")
#lines(errors_TBATS, col="grey")
#lines(errors_ARIMA, col="orange")
#legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), #col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cUK2_0), na.rm=TRUE)*100
mean(abs(errors_MMNF/cUK2_0), na.rm=TRUE)*100
mean(abs(errors_AAND/cUK2_0), na.rm=TRUE)*100
mean(abs(errors_MMND/cUK2_0), na.rm=TRUE)*100
mean(abs(errors_TBATS/cUK2_0), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cUK2_0), na.rm=TRUE)*100

```
Best model is BATS for UK:

```{r, echo=FALSE}
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 1 plots
plot(cUK2_0_tbats_pred, xlab="Time", ylab="Ac. deaths (UK)", ylim=c(0,10000))
lines(cUK3, col="red")
```


```{r}
library(forecast)

#covid_data<-read.csv(file.choose(), header=TRUE, sep=",")

t0=2020+53/365
P=15 #predicted days
cIT <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cIT_14 <- ts(log(covid_data$Cdeaths_IT[54:83]),start=t0, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cIT_F <- ts(log(covid_data$Cdeaths_IT[54:148]),start=t0, frequency=365)   # a supprimer 

plot(cIT_F)
lines(cIT_14, col="red")

cIT_14_AAN <- ets(cIT_14, model="AAN", damped=FALSE)
cIT_14_AAZ <- ets(cIT_14, model="AAZ", damped=FALSE)
cIT_14_MMN <- ets(cIT_14, model="MMN", damped=FALSE)
cIT_14_MMZ <- ets(cIT_14, model="MMZ", damped=FALSE)

cIT_14_AAND <- ets(cIT_14, model="AAN", damped=TRUE)
cIT_14_AAZD <- ets(cIT_14, model="AAZ", damped=TRUE)
cIT_14_MMND <- ets(cIT_14, model="MMN", damped=TRUE)
cIT_14_MMZD <- ets(cIT_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT_14_AAN_pred <- forecast(cIT_14_AAN, h=30, level=c(0.8, 0.95))
cIT_14_AAZ_pred <- forecast(cIT_14_AAZ, h=30, level=c(0.8, 0.95))
cIT_14_MMN_pred <- forecast(cIT_14_MMN, h=30, level=c(0.8, 0.95))
cIT_14_MMZ_pred <- forecast(cIT_14_MMZ, h=30, level=c(0.8, 0.95))

cIT_14_AAND_pred <- forecast(cIT_14_AAND, h=30, level=c(0.8, 0.95))
cIT_14_AAZD_pred <- forecast(cIT_14_AAZD, h=30, level=c(0.8, 0.95))
cIT_14_MMND_pred <- forecast(cIT_14_MMND, h=30, level=c(0.8, 0.95))
cIT_14_MMZD_pred <- forecast(cIT_14_MMZD, h=30, level=c(0.8, 0.95))

cIT_14_tbats <- tbats(cIT_14)
cIT_14_tbats_pred <-forecast(cIT_14_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))
plot(cIT_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate")
lines(cIT_F, col="red")

cIT_14_ARIMA <- auto.arima(cIT_14,seasonal=FALSE)
cIT_14_ARIMA_pred <- forecast(cIT_14_ARIMA,30)
plot(cIT_14_ARIMA_pred)
lines(cIT_F, col="red")

par(mfrow=c(2,3)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT_14_AAN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100))
lines(cIT_F, col="red")
plot(cIT_14_MMN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100))
lines(cIT_F, col="red")
plot(cIT_14_AAND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100))
lines(cIT_F, col="red")
plot(cIT_14_MMND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100))
lines(cIT_F, col="red")
plot(cIT_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate", ylim=c(0,100))
lines(cIT_F, col="red")
plot(cIT_14_ARIMA_pred, ylim=c(0,100))
lines(cIT_F, col="red")

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT_14, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT_14, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT_14, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT_14, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT_14, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT_14, f_ARIMA, h=1, window=15)


par(mfrow=c(1,1)) 
plot(errors_AANF, ylab='tsCV errors')
abline(0,0)
lines(errors_MMNF, col="red")
lines(errors_AAND, col="green")
lines(errors_MMND, col="blue")
lines(errors_TBATS, col="grey")
lines(errors_ARIMA, col="orange")
legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cIT_14), na.rm=TRUE)*100
mean(abs(errors_MMNF/cIT_14), na.rm=TRUE)*100
mean(abs(errors_AAND/cIT_14), na.rm=TRUE)*100
mean(abs(errors_MMND/cIT_14), na.rm=TRUE)*100
mean(abs(errors_TBATS/cIT_14), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cIT_14), na.rm=TRUE)*100

# Print the mean and confidence intervals for the MMZ model
cIT_14_MMN_pred

# Export the results out
write.csv(cIT_14_MMN_pred, file = "IT no lockdown+14d (AAND) incl(ARIMA).csv") # export the selected model's predictions into a CSV file

#expfore<-exp(cIT_14_ARIMA_pred$forecast)
par(mfrow=c(1,1)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT_14_AAND_pred, xlab="Year", ylab="log(Acummulated deaths)", ylim=c(0,20))
lines(cIT_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)



```

## 14 days after lockdown

We will further reproduce the same process for France and UK. 
Finally we obtain the 3 following plots:


```{r}
library(forecast)

####################
###ITALY ANALYSIS###
####################

#covid_data<-read.csv(file.choose(), header=TRUE, sep=",")

t0=2020+53/365
P=15 #predicted days
#FRA <- ts(covid_data$deaths_IT,start=0, frequency=1)
cIT <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cIT_14 <- ts(covid_data$Cdeaths_IT[54:83],start=t0, frequency=365) #t=0 @ day69. +14d #before it was starting at 45
cIT_F <- ts(covid_data$Cdeaths_IT[54:148],start=t0, frequency=365)   # a supprimer 

plot(cIT_F)
lines(cIT_14, col="red")

cIT_14_AAN <- ets(cIT_14, model="AAN", damped=FALSE)
cIT_14_AAZ <- ets(cIT_14, model="AAZ", damped=FALSE)
cIT_14_MMN <- ets(cIT_14, model="MMN", damped=FALSE)
cIT_14_MMZ <- ets(cIT_14, model="MMZ", damped=FALSE)

cIT_14_AAND <- ets(cIT_14, model="AAN", damped=TRUE)
cIT_14_AAZD <- ets(cIT_14, model="AAZ", damped=TRUE)
cIT_14_MMND <- ets(cIT_14, model="MMN", damped=TRUE)
cIT_14_MMZD <- ets(cIT_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cIT_14_AAN_pred <- forecast(cIT_14_AAN, h=30, level=c(0.8, 0.95))
cIT_14_AAZ_pred <- forecast(cIT_14_AAZ, h=30, level=c(0.8, 0.95))
cIT_14_MMN_pred <- forecast(cIT_14_MMN, h=30, level=c(0.8, 0.95))
cIT_14_MMZ_pred <- forecast(cIT_14_MMZ, h=30, level=c(0.8, 0.95))

cIT_14_AAND_pred <- forecast(cIT_14_AAND, h=30, level=c(0.8, 0.95))
cIT_14_AAZD_pred <- forecast(cIT_14_AAZD, h=30, level=c(0.8, 0.95))
cIT_14_MMND_pred <- forecast(cIT_14_MMND, h=30, level=c(0.8, 0.95))
cIT_14_MMZD_pred <- forecast(cIT_14_MMZD, h=30, level=c(0.8, 0.95))

cIT_14_tbats <- tbats(cIT_14)
cIT_14_tbats_pred <-forecast(cIT_14_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))

cIT_14_ARIMA <- auto.arima(cIT_14,seasonal=FALSE)
cIT_14_ARIMA_pred <- forecast(cIT_14_ARIMA,30)

par(mfrow=c(3,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cIT_14_AAN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
plot(cIT_14_MMN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
plot(cIT_14_AAND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
plot(cIT_14_MMND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cIT_F, col="red")
plot(cIT_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate", ylim=c(0,100000))
lines(cIT_F, col="red")
plot(cIT_14_ARIMA_pred, ylim=c(0,100000))
lines(cIT_F, col="red")

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cIT_14, f_AANF, h=1, window=15)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cIT_14, f_MMNF, h=1, window=15)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cIT_14, f_AAND, h=1, window=15)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cIT_14, f_MMND, h=1, window=15)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cIT_14, f_TBATS, h=1, window=15)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cIT_14, f_ARIMA, h=1, window=15)


par(mfrow=c(1,1)) 
plot(errors_AANF, ylab='tsCV errors')
abline(0,0)
lines(errors_MMNF, col="red")
lines(errors_AAND, col="green")
lines(errors_MMND, col="blue")
lines(errors_TBATS, col="grey")
lines(errors_ARIMA, col="orange")
legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cIT_14), na.rm=TRUE)*100
mean(abs(errors_MMNF/cIT_14), na.rm=TRUE)*100
mean(abs(errors_AAND/cIT_14), na.rm=TRUE)*100
mean(abs(errors_MMND/cIT_14), na.rm=TRUE)*100
mean(abs(errors_TBATS/cIT_14), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cIT_14), na.rm=TRUE)*100
```
Based on the mean errors, we conclude that for Italy, the best model is the MMND model

```{r}

# Print the mean and confidence intervals for the MMZ model
cIT_14_MMND_pred

# Export the results out
write.csv(cIT_14_MMND_pred, file = "IT no lockdown+14d (MMND) incl(ARIMA).csv") # export the selected model's predictions into a CSV file



```


We perform the same analysis for France and the UK. We decide to hide the steps performed as they are similar to those done for Italy. The best models for these 2 countries are the MMND and ARIMA models respectively. 



France  death count analysis 


```{r, echo=FALSE}
#####################
###France ANALYSIS###
####################


t0=2020+53/365
#P=15 #predicted days, à supprimer? 
#cFRA <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cFRA_14 <- ts(covid_data$Cdeaths_IT[58:89],start=t0, frequency=365) #t=0 @ day75. +14d 
cFRA_F <- ts(covid_data$Cdeaths_IT[58:148],start=t0, frequency=365)   # a supprimer?

plot(cFRA_F)
lines(cFRA_14, col="red")

cFRA_14_AAN <- ets(cFRA_14, model="AAN", damped=FALSE)
cFRA_14_AAZ <- ets(cFRA_14, model="AAZ", damped=FALSE)
cFRA_14_MMN <- ets(cFRA_14, model="MMN", damped=FALSE)
cFRA_14_MMZ <- ets(cFRA_14, model="MMZ", damped=FALSE)

cFRA_14_AAND <- ets(cFRA_14, model="AAN", damped=TRUE)
cFRA_14_AAZD <- ets(cFRA_14, model="AAZ", damped=TRUE)
cFRA_14_MMND <- ets(cFRA_14, model="MMN", damped=TRUE)
cFRA_14_MMZD <- ets(cFRA_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cFRA_14_AAN_pred <- forecast(cFRA_14_AAN, h=30, level=c(0.8, 0.95))
cFRA_14_AAZ_pred <- forecast(cFRA_14_AAZ, h=30, level=c(0.8, 0.95))
cFRA_14_MMN_pred <- forecast(cFRA_14_MMN, h=30, level=c(0.8, 0.95))
cFRA_14_MMZ_pred <- forecast(cFRA_14_MMZ, h=30, level=c(0.8, 0.95))

cFRA_14_AAND_pred <- forecast(cFRA_14_AAND, h=30, level=c(0.8, 0.95))
cFRA_14_AAZD_pred <- forecast(cFRA_14_AAZD, h=30, level=c(0.8, 0.95))
cFRA_14_MMND_pred <- forecast(cFRA_14_MMND, h=30, level=c(0.8, 0.95))
cFRA_14_MMZD_pred <- forecast(cFRA_14_MMZD, h=30, level=c(0.8, 0.95))

cFRA_14_tbats <- tbats(cFRA_14)
cFRA_14_tbats_pred <-forecast(cFRA_14_tbats, h=30, level=c(0.8, 0.95))
par(mfrow=c(1,1))
#plot(cFRA_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate")
#lines(cFRA_F, col="red")

cFRA_14_ARIMA <- auto.arima(cFRA_14,seasonal=FALSE)
cFRA_14_ARIMA_pred <- forecast(cFRA_14_ARIMA,30)
#plot(cFRA_14_ARIMA_pred)
#lines(cFRA_F, col="red")

par(mfrow=c(3,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cFRA_14_AAN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
plot(cFRA_14_MMN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
plot(cFRA_14_AAND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
plot(cFRA_14_MMND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cFRA_F, col="red")
plot(cFRA_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate", ylim=c(0,100000))
lines(cFRA_F, col="red")
plot(cFRA_14_ARIMA_pred, ylim=c(0,100000))
lines(cFRA_F, col="red")

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cFRA_14, f_AANF, h=1, window=10)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cFRA_14, f_MMNF, h=1, window=10)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cFRA_14, f_AAND, h=1, window=10)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cFRA_14, f_MMND, h=1, window=10)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cFRA_14, f_TBATS, h=1, window=10)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cFRA_14, f_ARIMA, h=1, window=10)


par(mfrow=c(1,1)) 
plot(errors_AANF, ylab='tsCV errors')
abline(0,0)
lines(errors_MMNF, col="red")
lines(errors_AAND, col="green")
lines(errors_MMND, col="blue")
lines(errors_TBATS, col="grey")
lines(errors_ARIMA, col="orange")
legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cFRA_14), na.rm=TRUE)*100
mean(abs(errors_MMNF/cFRA_14), na.rm=TRUE)*100
mean(abs(errors_AAND/cFRA_14), na.rm=TRUE)*100
mean(abs(errors_MMND/cFRA_14), na.rm=TRUE)*100
mean(abs(errors_TBATS/cFRA_14), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cFRA_14), na.rm=TRUE)*100

```

Based on the mean errors, we conclude that for France the best model is the TBATS model

```{r, echo=FALSE}


# Print the mean and confidence intervals for the MMZ model
cFRA_14_TBATS_pred

# Export the results out
write.csv(cFRA_14_TBATS_pred, file = "FRA no lockdown+14d (MMND) incl(ARIMA).csv") # export the selected model's predictions into a CSV file


```

UK death count analysis 


```{r, echo=FALSE}
#######################
#####UK Analysis#######
#######################


t0=2020+53/365
#P=15 #predicted days, à supprimer? 
#cUK <- ts(covid_data$Cdeaths_IT,start=0, frequency=1)
cUK_14 <- ts(covid_data$Cdeaths_IT[68:98],start=t0, frequency=365) #t=0 @ day84. +14d 
cUK_F <- ts(covid_data$Cdeaths_IT[68:148],start=t0, frequency=365)   # a supprimer?

plot(cUK_F)
lines(cUK_14, col="red")

cUK_14_AAN <- ets(cUK_14, model="AAN", damped=FALSE)
cUK_14_AAZ <- ets(cUK_14, model="AAZ", damped=FALSE)
cUK_14_MMN <- ets(cUK_14, model="MMN", damped=FALSE)
cUK_14_MMZ <- ets(cUK_14, model="MMZ", damped=FALSE)

cUK_14_AAND <- ets(cUK_14, model="AAN", damped=TRUE)
cUK_14_AAZD <- ets(cUK_14, model="AAZ", damped=TRUE)
cUK_14_MMND <- ets(cUK_14, model="MMN", damped=TRUE)
cUK_14_MMZD <- ets(cUK_14, model="MMZ", damped=TRUE)

# Create their prediction "cones" for 360 months (30 years) into the future with quintile confidence intervals
cUK_14_AAN_pred <- forecast(cUK_14_AAN, h=30, level=c(0.8, 0.95))
cUK_14_AAZ_pred <- forecast(cUK_14_AAZ, h=30, level=c(0.8, 0.95))
cUK_14_MMN_pred <- forecast(cUK_14_MMN, h=30, level=c(0.8, 0.95))
cUK_14_MMZ_pred <- forecast(cUK_14_MMZ, h=30, level=c(0.8, 0.95))

cUK_14_AAND_pred <- forecast(cUK_14_AAND, h=30, level=c(0.8, 0.95))
cUK_14_AAZD_pred <- forecast(cUK_14_AAZD, h=30, level=c(0.8, 0.95))
cUK_14_MMND_pred <- forecast(cUK_14_MMND, h=30, level=c(0.8, 0.95))
cUK_14_MMZD_pred <- forecast(cUK_14_MMZD, h=30, level=c(0.8, 0.95))

cUK_14_tbats <- tbats(cUK_14)
cUK_14_tbats_pred <-forecast(cUK_14_tbats, h=30, level=c(0.8, 0.95))


cUK_14_ARIMA <- auto.arima(cUK_14,seasonal=FALSE)
cUK_14_ARIMA_pred <- forecast(cUK_14_ARIMA,30)


par(mfrow=c(3,2)) # This command sets the plot window to show 1 row of 4 plots
plot(cUK_14_AAN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
plot(cUK_14_MMN_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
plot(cUK_14_AAND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
plot(cUK_14_MMND_pred, xlab="Year", ylab="Acummulated deaths", ylim=c(0,100000))
lines(cUK_F, col="red")
plot(cUK_14_tbats_pred, xlab="Year", ylab="Predicted Electric Rate", ylim=c(0,100000))
lines(cUK_F, col="red")
plot(cUK_14_ARIMA_pred, ylim=c(0,100000))
lines(cUK_F, col="red")

###
### Comparing models -- Time series Cross Validation (Rolling Horizon Holdout)
###

f_AANF  <- function(y, h) forecast(ets(y, model="AAN"), h = h)
errors_AANF <- tsCV(cUK_14, f_AANF, h=1, window=10)

f_MMNF<- function(y, h) forecast(ets(y, model="MMN"), h = h)
errors_MMNF <- tsCV(cUK_14, f_MMNF, h=1, window=10)

f_AAND  <- function(y, h) forecast(ets(y, model="AAN", damped=TRUE), h = h)
errors_AAND <- tsCV(cUK_14, f_AAND, h=1, window=10)

f_MMND  <- function(y, h) forecast(ets(y, model="MMN", damped=TRUE), h = h)
errors_MMND <- tsCV(cUK_14, f_MMND, h=1, window=10)

f_TBATS  <- function(y, h) forecast(tbats(y), h = h)
errors_TBATS <- tsCV(cUK_14, f_TBATS, h=1, window=10)

f_ARIMA  <- function(y, h) forecast(auto.arima(y), h = h)
errors_ARIMA <- tsCV(cUK_14, f_ARIMA, h=1, window=10)


par(mfrow=c(1,1)) 
plot(errors_AANF, ylab='tsCV errors')
abline(0,0)
lines(errors_MMNF, col="red")
lines(errors_AAND, col="green")
lines(errors_MMND, col="blue")
lines(errors_TBATS, col="grey")
lines(errors_ARIMA, col="orange")
legend("left", legend=c("CV_error_AANF", "CV_error_MMNF","CV_error_AAND","CV_error_MMND", "CV_error_TBATS", "CV_error_ARIMA"), col=c("black", "red", "green", "blue", "grey", "orange"), lty=1:4)

mean(abs(errors_AANF/cUK_14), na.rm=TRUE)*100
mean(abs(errors_MMNF/cUK_14), na.rm=TRUE)*100
mean(abs(errors_AAND/cUK_14), na.rm=TRUE)*100
mean(abs(errors_MMND/cUK_14), na.rm=TRUE)*100
mean(abs(errors_TBATS/cUK_14), na.rm=TRUE)*100
mean(abs(errors_ARIMA/cUK_14), na.rm=TRUE)*100

```

Based on the mean errors, we conclude that for France the best model is the ARIMA model

```{r, echo=FALSE}


# Print the mean and confidence intervals for the MMZ model
cUK_14_ARIMA_pred

# Export the results out
write.csv(cUK_14_ARIMA_pred, file = "UK no lockdown+14d (MMND) incl(ARIMA).csv") # export the selected model's predictions into a CSV file

```
After 14 days of lockdown, the projections of death for all countries are: 

```{r}
########################################
#########Plot the 3 countries###########
########################################


#expfore<-exp(cIT_14_ARIMA_pred$forecast)
 
plot(cIT_14_MMND_pred, xlab="Year", ylab="Italy Acummulated deaths", ylim=c(0,250000))
lines(cIT_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)

plot(cFRA_14_TBATS_pred, xlab="Year", ylab="France Acummulated deaths", ylim=c(0,250000))
lines(cFRA_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)

plot(cUK_14_ARIMA_pred, xlab="Year", ylab="UK Acummulated deaths", ylim=c(0,250000))
lines(cUK_F, col="red")
abline(v=2020+69/365, col="green")
legend("left", legend=c("Best fitted model","Real death toll", "Start of Lockdown"), col=c("blue", "red","green"), lty=1)


#######################
#########Fin###########
#######################


```


## 28 days after lockdown

We will further reproduce the same process for France and UK. 
Finally we obtain the 3 following plots:

## 56 days after lockdown 

We will further reproduce the same process for France and UK. 
Finally we obtain the 3 following plots:

# End of Project Proposal

By looking at the predicion models, we see that France has adopted the best approach in comparison with Italy and United Kingdom. 
Helped by the Italian experience, France has pronounced the lockdown before reach a very damageable tipping point. The predicting curve of martality rate at Lockdown date suggests that Italy had taken the least effective measures. 

This analysis is confirmed with the post-14 days observations that assess the real impact of the lockdown after the incubation period. 

Finally, the post-56 days data shows that UK is in the worst situation as the curve of infection is still very steep. In terms of business implication, it also means that UK might have to wait longer than France and Italy to deconfine. 
This conclusion sounds quite logical as the virus spread was exponential. Therefore, the longer a country has waited to pronounce the confinement, the more spread was the virus with the multiplicative consequences it engenders, and the longer it will take to stop the contamination. 

Overall, from an economic perspective, UK might have more to lose by havong waited longer to pronounce lockdown while Italy and France are in better position to relaunch their economy. 

Nevertheless, the analysis presents some limitations as we have not taken into account some factors such as the density of the population, nor segmented countries into areas at different level of contamination risks. The stringency of the lockdown has been assumed
Moreover, economic or political terms have not been taken into account in our analaysis. Indeed, the Brexit and tense political situation might have pushed UK's government to defer the confinement date in order to diminish the economic impact of the covid-19. In France, the confinement has been announced just after political vote. 
